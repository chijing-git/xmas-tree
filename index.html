<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas 3D Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000510; }
        /* --- 修改了文字样式 --- */
        #info {
            position: absolute;
            top: 15%; /* 调整文字位置到画面上方 */
            width: 100%;
            text-align: center;
            color: #ffebc7; /* 温暖的米金色 */
            /* 使用手写风格字体，如果系统没有则回退到通用手写体 */
            font-family: 'Brush Script MT', 'Comic Sans MS', cursive;
            font-size: 72px; /* 字体变大 */
            pointer-events: none; /* 关键：让鼠标事件穿透文字，不影响拖动模型 */
            text-shadow: 0 0 15px #ff8c00, 0 0 30px #ff4500; /* 添加暖色辉光 */
            z-index: 10;
            user-select: none; /* 禁止选中文字 */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info">Merry Christmas</div>

    <script>
        // --- 1. 程序化生成贴图 (保持不变) ---
        function createParticleTexture() {
            var canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createSnowTexture() {
            var canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; // 稍微大一点让线条更清晰
            var ctx = canvas.getContext('2d');
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.translate(32, 32);
            for(var i=0; i<3; i++) {
                ctx.beginPath();
                ctx.moveTo(0, -24); ctx.lineTo(0, 24);
                ctx.stroke();
                ctx.rotate(Math.PI / 3);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- 2. 主场景逻辑 (保持不变) ---
        var scene, camera, renderer, controls;
        var treeSystem, snowSystem;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000510, 0.002);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 20, 90);
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.enablePan = false; // 禁止平移，防止视角跑偏

            // --- 生成树 ---
            var treeGeo = new THREE.BufferGeometry();
            var treeCount = 70000; 
            var positions = [];
            var colors = [];
            var color1 = new THREE.Color(0x003399); // 深蓝
            var color2 = new THREE.Color(0x44ccff); // 亮蓝

            for (var i = 0; i < treeCount; i++) {
                var h = Math.random();
                var n_layers = 16.0;
                var taper = 22 * (1.0 - Math.pow(h, 0.9));
                var layer = 1.0 - ((h * n_layers) % 1.0) * 0.7;
                var r = taper * layer * (0.8 + Math.random() * 0.4);
                
                var theta = Math.random() * Math.PI * 2 + h * 12;
                
                var x = r * Math.cos(theta);
                var y = h * 55 - 25;
                var z = r * Math.sin(theta);

                positions.push(x, y, z);

                var mix = h * 0.4 + (r / 25) * 0.6;
                var c = color1.clone().lerp(color2, mix);
                
                if (Math.random() > 0.99) {
                    colors.push(1.0, 0.9, 0.5); // 偶尔的金点
                } else {
                    colors.push(c.r, c.g, c.b);
                }
            }

            treeGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            treeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            var treeMat = new THREE.PointsMaterial({
                size: 0.9,
                map: createParticleTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            treeSystem = new THREE.Points(treeGeo, treeMat);
            scene.add(treeSystem);

            // --- 生成雪花 ---
            var snowGeo = new THREE.BufferGeometry();
            var snowCount = 1500;
            var snowPos = [];
            for (var i = 0; i < snowCount; i++) {
                snowPos.push(
                    (Math.random() - 0.5) * 120,
                    Math.random() * 100 - 50,
                    (Math.random() - 0.5) * 120
                );
            }
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
            
            var snowMat = new THREE.PointsMaterial({
                size: 2.5,
                map: createSnowTexture(),
                color: 0xffffff,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (snowSystem) {
                var positions = snowSystem.geometry.attributes.position.array;
                for (var i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.06; 
                    if (positions[i] < -50) {
                        positions[i] = 50;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y += 0.0005;
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>